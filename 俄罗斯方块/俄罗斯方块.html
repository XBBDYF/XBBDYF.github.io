<!DOCTYPE html>
<html lang="zh">

<head>
    <meta charset="UTF-8">
    <title>HTML5ä¿„ç½—æ–¯æ–¹å—</title>
    <style>
        body {
            background: #1a1a2e;
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
            margin: 0;
            font-family: 'Arial', sans-serif;
            color: white;
        }

        .game-container {
            position: relative;
            display: flex;
            gap: 30px;
            background: #2d2d44;
            padding: 20px;
            border-radius: 10px;
            box-shadow: 0 0 20px rgba(0, 255, 255, 0.3);
            border: 2px solid var(--accent-color);
            box-shadow: 0 0 30px rgba(78, 205, 196, 0.2);
        }

        .game-container {
            /* åŸæœ‰æ ·å¼ */
            max-width: 90vw;
            max-height: 90vh;
            overflow: auto;
            flex-wrap: wrap;
            /* æ·»åŠ æ¢è¡Œæ˜¾ç¤º */
        }

        /* è°ƒæ•´æ§åˆ¶é¢æ¿ä½ç½® */
        .control-panel {
            position: sticky;
            top: 20px;
            left: 20px;
        }

        #gameBoard {
            font-family: "Segoe UI Emoji", "Apple Color Emoji", sans-serif;
            border: 3px solid var(--border-primary);
            background: var(--game-bg);
            border-radius: 8px;
            position: relative;
        }


        .block-cell {
            position: relative;
        }

        .block-cell::before {
            content: '';
            position: absolute;
            top: 2px;
            left: 2px;
            right: 2px;
            bottom: 2px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 3px;
        }

        .control-panel {
            display: flex;
            flex-direction: column;
            gap: 20px;
        }

        .next-block canvas {
            background: #1a1a2e;
            border: 2px solid #4a4a6a;
        }

        .buttons button {
            background: #4CAF50;
            border: none;
            padding: 10px 20px;
            color: white;
            cursor: pointer;
            transition: 0.3s;
        }

        /* æŒ‰é’®æ‚¬åœæ•ˆæœ */
        .buttons button:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.2);
        }

        .buttons button:active {
            transform: translateY(1px);
        }

        /* åˆ†æ•°æ ·å¼ä¼˜åŒ– */
        .score-box {
            background: var(--bg-secondary);
            padding: 12px 20px;
            border-radius: 8px;
            text-align: center;
        }

        .score-box h2 {
            margin: 0;
            font-size: 1.4em;
        }

        /* ä¸‹ä¸€ä¸ªæ–¹å—é¢„è§ˆæ ·å¼ */
        .next-block canvas {
            border-radius: 6px;
        }


        /* æŒ‡å—æ ·å¼ */
        .controls-guide {
            position: fixed;
            bottom: 30px;
            left: 50%;
            transform: translateX(-50%);
            background: var(--panel-bg);
            padding: 15px 25px;
            border-radius: 12px;
            display: flex;
            gap: 25px;
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.2);
            border: 1px solid var(--border-primary);
        }

        .control-item {
            display: flex;
            align-items: center;
            gap: 8px;
            color: var(--text-primary);
        }

        .key {
            background: var(--bg-secondary);
            padding: 6px 12px;
            border-radius: 6px;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
            border: 1px solid var(--border-primary);
            font-family: monospace;
        }

        /* é»‘å¤œç™½å¤©æ¨¡å¼åˆ‡æ¢ */
        :root {
            --bg-primary: #f0f2f5;
            --bg-secondary: #ffffff;
            --text-primary: #333333;
            --border-primary: #e0e0e0;
            --accent-color: #3498db;
            --game-bg: #0f0f1a;
            --panel-bg: #ffffff;
        }

        [data-theme="dark"] {
            --bg-primary: #1a1a2e;
            --bg-secondary: #2d2d44;
            --text-primary: #e0e0e0;
            --border-primary: #4a4a6a;
            --accent-color: #4ECDC4;
            --game-bg: #0a0a12;
            --panel-bg: #2d2d44;
        }

        body {
            background: var(--bg-primary);
            color: var(--text-primary);
            transition: background 0.3s ease;
        }

        .game-container {
            background: var(--panel-bg);
            box-shadow: 0 0 20px rgba(0, 255, 255, 0.3);
        }

        #gameBoard {
            border: 3px solid var(--border-primary);
            background: var(--game-bg);
        }

        .control-panel {
            background: var(--panel-bg);
            padding: 15px;
            border-radius: 8px;
            border: 1px solid var(--border-primary);
        }

        .buttons button {
            background: var(--accent-color);
            color: white;
            border-radius: 4px;
        }

        /* ä¸»é¢˜åˆ‡æ¢æŒ‰é’®æ ·å¼ */
        .theme-switch {
            display: flex;
            align-items: center;
            gap: 10px;
            background: var(--panel-bg);
            padding: 8px 12px;
            border-radius: 8px;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
        }

        .switch {
            position: relative;
            display: inline-block;
            width: 40px;
            height: 20px;
        }

        .slider {
            position: absolute;
            cursor: pointer;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background-color: #95a5a6;
            transition: .4s;
            border-radius: 34px;
        }

        .slider:before {
            position: absolute;
            content: "";
            height: 16px;
            width: 16px;
            left: 2px;
            bottom: 2px;
            background-color: white;
            transition: .4s;
            border-radius: 50%;
        }

        input:checked+.slider {
            background-color: var(--accent-color);
        }

        input:checked+.slider:before {
            transform: translateX(20px);
        }

        .style-menu {
            position: fixed;
            /* æ”¹ä¸ºå›ºå®šå®šä½ */
            left: 20px;
            /* è°ƒæ•´åˆ°è§†å£å·¦ä¾§ */
            top: 80px;
            /* ä¸‹ç§»é¿å…ä¸ä¸»é¢˜åˆ‡æ¢æŒ‰é’®é‡å  */
            z-index: 1000;
            /* ç¡®ä¿åœ¨æœ€ä¸Šå±‚ */
            background: var(--panel-bg);
            padding: 10px;
            border-radius: 8px;
            border: 1px solid var(--border-primary);
        }

        .style-menu select {
            background: var(--bg-secondary);
            color: var(--text-primary);
            border: 1px solid var(--border-primary);
            padding: 8px;
            border-radius: 4px;
            cursor: pointer;
        }

        /* çˆ†ç‚¸åŠ¨ç”»ç›¸å…³æ ·å¼ */
        .game-over-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(255, 255, 255, 0.9);
            animation: blast 1.5s ease-out forwards;
            pointer-events: none;
            opacity: 0;
        }

        @keyframes blast {
            0% {
                transform: scale(0);
                opacity: 0;
            }

            50% {
                transform: scale(2);
                opacity: 0.8;
            }

            100% {
                transform: scale(1);
                opacity: 0;
            }
        }

        /* æ–¹å—ä¸»é¢˜ */
        /* æ–¹å—é¢œè‰²å˜é‡å®šä¹‰ */
        :root {
            --color-0: #FF6B6B;
            --color-1: #4ECDC4;
            --color-2: #45B7D1;
            --color-3: #96CEB4;
            --color-4: #FFEEAD;
            --color-5: #D4A5A5;
            --color-6: #99B898;
            --color-bomb: #FF0000;

            /* ç³–æœä¸»é¢˜é¢œè‰² */
            --candy-0: #FF9AA2;
            --candy-1: #B5EAD7;
            --candy-2: #C7CEEA;
            --candy-3: #FFB7B2;
            --candy-4: #FFFFD8;
            --candy-5: #E2F0CB;
            --candy-6: #B5EAD7;
            --candy-bomb: #FF6961;

            /* å¤å¤ä¸»é¢˜é¢œè‰² */
            --retro-0: #0F380F;
            --retro-1: #306230;
            --retro-2: #8BAC0F;
            --retro-3: #9BBC0F;
            --retro-4: #0F380F;
            --retro-5: #306230;
            --retro-6: #8BAC0F;
            --retro-bomb: #FF0018;

            /* é‡‘å±ä¸»é¢˜é¢œè‰² */
            --metal-0: #7F7F7F;
            --metal-1: #A9A9A9;
            --metal-2: #808080;
            --metal-3: #696969;
            --metal-4: #778899;
            --metal-5: #708090;
            --metal-6: #2F4F4F;
            --metal-bomb: #B22222;

            /* ç»ç’ƒä¸»é¢˜é¢œè‰² */
            --glass-0: rgba(145, 216, 228, 0.5);
            /* åŠé€æ˜æµ…è“ */
            --glass-1: rgba(158, 234, 125, 0.5);
            --glass-2: rgba(255, 211, 105, 0.5);
            --glass-3: rgba(255, 152, 152, 0.5);
            --glass-4: rgba(197, 181, 253, 0.5);
            --glass-5: rgba(130, 202, 255, 0.5);
            --glass-6: rgba(255, 203, 107, 0.5);
            --glass-bomb: rgba(255, 75, 75, 0.7);
            /* åŠé€æ˜çº¢è‰² */
            --glass-border: rgba(50, 70, 80, 0.8);
            /* ç»ç’ƒè¾¹æ¡†è‰² */

            --neon-0: #FF0077;
            --neon-1: #00FF88;
            --neon-2: #FFDD00;
            --neon-3: #FF6600;
            --neon-4: #00FFFF;
            --neon-5: #CC00FF;
            --neon-6: #FF0099;
            --neon-bomb: #FFFFFF;

            --forest-0: #2D5A27;
            --forest-1: #568E3D;
            --forest-2: #8CB369;
            --forest-3: #B0C47B;
            --forest-4: #D4E6B5;
            --forest-5: #6B8F71;
            --forest-6: #A4C3B2;
            --forest-bomb: #FF6B35;

            --ocean-0: #005F73;
            --ocean-1: #0A9396;
            --ocean-2: #94D2BD;
            --ocean-3: #E9D8A6;
            --ocean-4: #9B5DE5;
            --ocean-5: #00F5D4;
            --ocean-6: #7AE582;
            --ocean-bomb: #FF006E;
        }

        [data-theme="dark"] {
            --color-0: #FF4757;
            --color-1: #2ED573;
            --color-2: #1E90FF;
            --color-3: #FFA502;
            --color-4: #FFD700;
            --color-5: #7BED9F;
            --color-6: #70A1FF;
            --color-bomb: #FF5555;

            /* æš—è‰²ç³»ç³–æœä¸»é¢˜ */
            --candy-0: #FF6B6B;
            --candy-1: #4ECDC4;
            --candy-2: #45B7D1;
            --candy-3: #96CEB4;
            --candy-4: #FFEEAD;
            --candy-5: #D4A5A5;
            --candy-6: #99B898;
            --candy-bomb: #FF5555;

            /* å¤å¤ä¸»é¢˜ä¿æŒåŸè‰² */
            --retro-0: #0F380F;
            --retro-1: #306230;
            --retro-2: #8BAC0F;
            --retro-3: #9BBC0F;
            --retro-4: #0F380F;
            --retro-5: #306230;
            --retro-6: #8BAC0F;
            --retro-bomb: #FF0018;

            /* æš—è‰²é‡‘å±ä¸»é¢˜ */
            --metal-0: #5A5A5A;
            --metal-1: #808080;
            --metal-2: #696969;
            --metal-3: #4F4F4F;
            --metal-4: #4A5568;
            --metal-5: #3B4F6B;
            --metal-6: #1E2B37;
            --metal-bomb: #8B0000;

            /* æš—è‰²ç»ç’ƒä¸»é¢˜ */
            --glass-0: rgba(76, 175, 193, 0.8);
            --glass-1: rgba(88, 164, 76, 0.8);
            --glass-2: rgba(193, 141, 45, 0.8);
            --glass-3: rgba(193, 92, 92, 0.8);
            --glass-4: rgba(137, 121, 193, 0.8);
            --glass-5: rgba(80, 142, 193, 0.8);
            --glass-6: rgba(193, 143, 45, 0.8);
            --glass-bomb: rgba(193, 45, 45, 0.9);


            --neon-0: #FF0066;
            --neon-1: #00FF77;
            --neon-2: #FFD700;
            --neon-3: #FF5500;
            --neon-4: #00EEEE;
            --neon-5: #CC00EE;
            --neon-6: #FF0088;
            --neon-bomb: #FFEE00;

            --forest-0: #1E3F20;
            --forest-1: #3C6E40;
            --forest-2: #7CA982;
            --forest-3: #A8C686;
            --forest-4: #C8E0B8;
            --forest-5: #4A7856;
            --forest-6: #8FBC8F;
            --forest-bomb: #FF4500;

            --ocean-0: #003E4C;
            --ocean-1: #007F8C;
            --ocean-2: #7FB3B0;
            --ocean-3: #D4E09B;
            --ocean-4: #8A4FFF;
            --ocean-5: #00D4B8;
            --ocean-6: #6CDE8A;
            --ocean-bomb: #FF1493;
        }

        .glass-debris {
            filter: drop-shadow(0 0 2px rgba(255, 255, 255, 0.5));
        }

        /* æ‰‹æœºç«¯å“åº”å¼æ ·å¼ */
        @media screen and (max-width: 600px) {
            .game-container {
                flex-direction: column;
                padding: 10px;
                gap: 15px;
                max-height: 95vh;
            }

            #gameBoard {
                width: 100% !important;
                height: auto !important;
                aspect-ratio: 1/2;
            }

            .control-panel {
                position: static;
                flex-direction: row;
                flex-wrap: wrap;
                justify-content: space-around;
                gap: 10px;
            }

            .next-block canvas {
                width: 60px !important;
                height: 60px !important;
            }

            .buttons button {
                padding: 12px 24px;
                font-size: 16px;
            }

            .controls-guide {
                bottom: 10px;
                padding: 10px;
                gap: 12px;
                flex-wrap: wrap;
            }

            .control-item {
                font-size: 12px;
            }

            .key {
                padding: 4px 8px;
            }

            /* æ·»åŠ è™šæ‹Ÿæ§åˆ¶é¢æ¿ */
            .mobile-controls {
                display: flex;
                position: fixed;
                bottom: 20px;
                left: 0;
                right: 0;
                justify-content: center;
                gap: 15px;
                touch-action: manipulation;
            }

            .mobile-btn {
                width: 50px;
                height: 50px;
                background: rgba(255, 255, 255, 0.2);
                border-radius: 50%;
                display: flex;
                align-items: center;
                justify-content: center;
                font-size: 24px;
                user-select: none;
            }
        }
    </style>
</head>

<body>
    <div class="theme-switch-container" style="position: absolute; top: 20px; right: 20px; z-index: 1000;">
        <div class="theme-switch">
            <button onclick="toggleMute()" style="margin-right:10px">ğŸ”Š</button>
            <label class="switch">
                <input type="checkbox" id="themeToggle">
                <span class="slider"></span>
            </label>
            <span class="theme-label">å¤œé—´æ¨¡å¼</span>
        </div>
    </div>
    <div class="game-container">
        <div class="style-menu">
            <select id="boardSize" onchange="changeBoardSize()">
                <option value="10x20">æ ‡å‡† (10x20)</option>
                <option value="15x30">å¤§å‹ (15x30)</option>
                <option value="20x40">è¶…å¤§ (20x40)</option>
            </select>
            <select id="blockStyle" onchange="updateBlockStyle()">
                <option value="default">é»˜è®¤æ–¹å—</option>
                <option value="neon">éœ“è™¹è¾¹æ¡†</option>
                <option value="gradient">æ¸å˜å¡«å……</option>
                <option value="pixel">åƒç´ é£æ ¼</option>
                <option value="candy">ç³–æœé£æ ¼</option>
                <option value="retro">å¤å¤é£æ ¼</option>
                <option value="metal">é‡‘å±é£æ ¼</option>
                <option value="glass">ç»ç’ƒé£æ ¼</option>
                <option value="neon">éœ“è™¹é£æ ¼</option>
                <option value="forest">æ£®æ—é£æ ¼</option>
                <option value="ocean">æµ·æ´‹é£æ ¼</option>
            </select>
        </div>
        <canvas id="gameBoard" width="300" height="600"></canvas>
        <div class="control-panel">
            <div class="score-box">
                <h2>åˆ†æ•° <span id="score">0</span></h2>
            </div>
            <div class="next-block">
                <h3>ä¸‹ä¸€ä¸ªæ–¹å—</h3>
                <canvas id="nextBlock" width="80" height="80"></canvas>
            </div>
            <div class="buttons">
                <button onclick="startGame()">å¼€å§‹æ¸¸æˆ</button>
                <button onclick="pauseGame()">æš‚åœ(P)</button>
            </div>
        </div>
    </div>
    <div class="controls-guide">
        <div class="control-item">
            <span class="key">â†</span> å·¦ç§»
        </div>
        <div class="control-item">
            <span class="key">â†’</span> å³ç§»
        </div>
        <div class="control-item">
            <span class="key">â†‘</span> æ—‹è½¬
        </div>
        <div class="control-item">
            <span class="key">â†“</span> åŠ é€Ÿ
        </div>
        <div class="control-item">
            <span class="key">ç©ºæ ¼</span> ç¬é™
        </div>
        <div class="control-item">
            <span class="key">P</span> æš‚åœ
        </div>
    </div>
    <audio id="bgMusic" loop src="https://www.tetris.com/sounds/tetris_bg_music.mp3"></audio>

    <div class="mobile-controls">
        <div class="mobile-btn left-btn">â†</div>
        <div class="mobile-btn rotate-btn">â†»</div>
        <div class="mobile-btn right-btn">â†’</div>
        <div class="mobile-btn down-btn">â†“</div>
    </div>
    <script>
        // æ¸¸æˆåˆå§‹åŒ–æ¸¸æˆåˆå§‹åŒ–
        // const CELL_SIZE = 30;
        // const COLS = 10, ROWS = 20;
        let COLS = 10;
        let ROWS = 20;
        const CELL_SIZE = 30;
        let score = 0;
        let isPaused = false; //æš‚åœçŠ¶æ€æ ‡è¯†
        let particles = []; // ç²’å­æ•°ç»„
        // æ¸¸æˆå¾ªç¯å’Œæ¸²æŸ“é€»è¾‘
        let lastTime = 0;
        const frameRate = 60; // ç‹¬ç«‹æ¸²æŸ“å¸§ç‡
        // æ¸¸æˆç»“æŸç›¸å…³å˜é‡
        let isGameOver = true;
        let explosionAnimations = [];
        let shakeIntensity = 0;
        let whiteAlpha = 0;
        // æ–¹å—æ ·å¼æ§åˆ¶
        let currentStyle = 'default';
        // åœ¨æ¸¸æˆåˆå§‹åŒ–æ—¶æ·»åŠ è£‚ç¼æ•°ç»„
        let cracks = Array(ROWS).fill().map(() => Array(COLS).fill(false));
        // çˆ†ç‚¸é¢œè‰²
        let bombColor;
        // let bombBoard = Array(ROWS).fill().map(() => Array(COLS).fill(false));
        // åœ¨å…¨å±€å˜é‡åŒºåŸŸæ·»åŠ éŸ³é¢‘ç›¸å…³å˜é‡
        let audioContext;
        let gainNode;
        let isMuted = false;
        const bgMusic = document.getElementById('bgMusic');
        // let activeCracks = [];
        // let needGenerateCracks = false;
        const GRID_SIZE = 30; // æ–°å¢ç½‘æ ¼å°ºå¯¸å®šä¹‰
        let glassDebris = []; // æ–°å¢ç©ºé—´åˆ†åŒºç½‘æ ¼æ•°ç»„

        // è§¦æ§äº‹ä»¶å¤„ç†
        let touchStartX = 0;
        let touchStartY = 0;
        const touchThreshold = 30;

        // æ ¼å­é¢ç§¯
        function changeBoardSize() {
            const size = document.getElementById('boardSize').value.split('x');
            COLS = parseInt(size[0]);
            ROWS = parseInt(size[1]);

            const gameBoard = document.getElementById('gameBoard');
            gameBoard.width = COLS * CELL_SIZE;
            gameBoard.height = ROWS * CELL_SIZE;

            // é‡ç½®æ¸¸æˆ
            if (gameInterval) {
                clearInterval(gameInterval);
                gameInterval = null;
            }
            isGameOver = true;
            startGame();
        }

        // åˆå§‹åŒ–éŸ³é¢‘ä¸Šä¸‹æ–‡
        function initAudio() {
            if (!audioContext) {
                audioContext = new (window.AudioContext || window.webkitAudioContext)();
                gainNode = audioContext.createGain();
                gainNode.connect(audioContext.destination);
            }
        }

        // éŸ³æ•ˆç”Ÿæˆå‡½æ•°
        function playTone(frequency, duration, type = 'sine') {
            if (isMuted) return;

            initAudio();
            const oscillator = audioContext.createOscillator();
            const envelope = audioContext.createGain();

            oscillator.type = type;
            oscillator.frequency.setValueAtTime(frequency, audioContext.currentTime);

            envelope.gain.setValueAtTime(0.2, audioContext.currentTime);
            envelope.gain.exponentialRampToValueAtTime(0.001, audioContext.currentTime + duration);

            oscillator.connect(envelope);
            envelope.connect(gainNode);

            oscillator.start();
            oscillator.stop(audioContext.currentTime + duration);
        }

        // æ¸¸æˆéŸ³æ•ˆ
        const soundEffects = {
            move: () => playTone(523, 0.05),
            rotate: () => playTone(659, 0.08),
            drop: () => playTone(784, 0.1),
            clearLine: () => {
                playTone(440, 0.2);
                playTone(554, 0.2);
            },
            bomb: () => {
                const now = audioContext.currentTime;
                const noise = audioContext.createBufferSource();
                const buffer = audioContext.createBuffer(1, audioContext.sampleRate * 0.5, audioContext.sampleRate);
                const data = buffer.getChannelData(0);

                for (let i = 0; i < buffer.length; i++) {
                    data[i] = Math.random() * 2 - 1;
                }

                noise.buffer = buffer;
                const filter = audioContext.createBiquadFilter();
                filter.type = 'bandpass';
                filter.frequency.setValueAtTime(1000, now);

                const gain = audioContext.createGain();
                gain.gain.setValueAtTime(0.5, now);
                gain.gain.exponentialRampToValueAtTime(0.01, now + 0.5);

                noise.connect(filter);
                filter.connect(gain);
                gain.connect(gainNode);
                noise.start();
                noise.stop(now + 0.5);
            },
            gameOver: () => {
                playTone(220, 1.5, 'square');
                playTone(110, 1.5, 'sawtooth');
            },
            glassBreak: () => {
                playTone(1200, 0.3, 'sawtooth');
                playTone(800, 0.3, 'square');
            }
        };

        function toggleMute() {
            isMuted = !isMuted;
            gainNode.gain.setValueAtTime(isMuted ? 0 : 1, audioContext.currentTime);
            bgMusic.muted = isMuted;
        }

        function updateBlockStyle() {
            currentStyle = document.getElementById('blockStyle').value;
            drawBoard();
            drawNext();
        }


        // é¢œè‰²å‡½æ•°
        function shadeColor(color, percent) {
            let R = parseInt(color.substring(1, 3), 16);
            let G = parseInt(color.substring(3, 5), 16);
            let B = parseInt(color.substring(5, 7), 16);

            R = parseInt(R * (100 + percent) / 100);
            G = parseInt(G * (100 + percent) / 100);
            B = parseInt(B * (100 + percent) / 100);

            R = (R < 255) ? R : 255;
            G = (G < 255) ? G : 255;
            B = (B < 255) ? B : 255;

            const RR = R.toString(16).length == 1 ? "0" + R.toString(16) : R.toString(16);
            const GG = G.toString(16).length == 1 ? "0" + G.toString(16) : G.toString(16);
            const BB = B.toString(16).length == 1 ? "0" + B.toString(16) : B.toString(16);

            return "#" + RR + GG + BB;
        }

        // æ¸¸æˆæ¿äºŒç»´æ•°ç»„
        let board = Array(ROWS).fill().map(() => Array(COLS).fill(0));

        // æ–¹å—å½¢çŠ¶å®šä¹‰ [6](@ref)
        const SHAPES = [
            [[1, 1, 1, 1]],                         // Iå‹
            [[1, 1, 1], [0, 1, 0]],                 // Tå‹
            [[1, 1, 1], [1, 0, 0]],                 // Lå‹
            [[1, 1, 1], [0, 0, 1]],                 // Jå‹
            [[1, 1], [1, 1]],                     // Oå‹
            [[1, 1, 0], [0, 1, 1]],                 // Så‹
            [[0, 1, 1], [1, 1, 0]]                  // Zå‹
        ];

        // é¢œè‰²è·å–æ–¹å¼
        let COLORS = [];
        // const COLORS = ["#FF6B6B", "#4ECDC4", "#45B7D1", "#96CEB4", "#FFEEAD", "#D4A5A5", "#99B898"];

        function updateColors() {
            const root = document.documentElement;
            const styleMap = {
                default: 'color',
                neon: 'neon',
                forest: 'forest',
                ocean: 'ocean',
                candy: 'candy',
                retro: 'retro',
                metal: 'metal',
                glass: 'glass'
            };

            const prefix = styleMap[currentStyle] || 'color';
            COLORS = Array.from({ length: 7 }, (_, i) =>
                getComputedStyle(root).getPropertyValue(`--${prefix}-${i}`).trim()
            );
            bombColor = getComputedStyle(root).getPropertyValue(`--${prefix}-bomb`).trim();
        }

        // æ–¹å—ç±»å®ç°
        class Tetromino {

            // constructor() {
            //     this.shapeIndex = Math.floor(Math.random() * 7);  // ä¿å­˜åˆå§‹å½¢çŠ¶ç´¢å¼•
            //     this.shape = SHAPES[this.shapeIndex];
            //     this.color = COLORS[this.shapeIndex];
            //     this.x = Math.floor(COLS / 2) - Math.floor(this.shape[0].length / 2);
            //     this.y = 0;
            // }
            // åœ¨ Tetromino ç±»çš„æ„é€ å‡½æ•°ä¸­ä¿®æ”¹ä»¥ä¸‹ä»£ç 
            constructor() {
                this.impactPoints = []; // åˆå§‹åŒ–ç¢°æ’ç‚¹æ•°ç»„
                this.shapeIndex = Math.floor(Math.random() * 7);
                this.shape = SHAPES[this.shapeIndex].map(row =>
                    row.map(cell => cell ? this.shapeIndex + 1 : 0)
                );
                this.color = COLORS[this.shapeIndex];
                this.bombCells = [];

                if (Math.random() < 0.3) {
                    const cells = [];
                    this.shape.forEach((row, dy) => {
                        row.forEach((cellVal, dx) => {
                            if (cellVal !== 0) cells.push({ dy, dx });
                        });
                    });

                    if (cells.length > 0) {
                        const randomIndex = Math.floor(Math.random() * cells.length);
                        const { dy, dx } = cells[randomIndex];
                        this.shape[dy][dx] = 8; // å°†ç‚¸å¼¹å•å…ƒæ ¼è®¾ä¸º8
                        this.bombCells.push({ dy, dx });
                    }
                }

                this.x = Math.floor(COLS / 2) - Math.floor(this.shape[0].length / 2);
                this.y = 0;
            }

            addImpactPoint(x, y) {
                this.impactPoints.push({ x, y });
            }

            // æ—‹è½¬é€»è¾‘ [2](@ref)
            rotate() {
                const newShape = this.shape[0].map((_, i) =>
                    this.shape.map(row => row[i]).reverse()
                );
                if (!this.collision(0, 0, newShape)) {
                    this.shape = newShape;
                }
            }

            // ç¢°æ’æ£€æµ‹ [4](@ref)
            collision(offsetX, offsetY, testShape = this.shape) {
                return testShape.some((row, dy) =>
                    row.some((cell, dx) =>
                        cell && (
                            this.x + dx + offsetX < 0 ||
                            this.x + dx + offsetX >= COLS ||
                            this.y + dy + offsetY >= ROWS ||
                            board[this.y + dy + offsetY][this.x + dx + offsetX]
                        )
                    )
                );
            }
        }

        let nextPiece = null; // æ–°å¢ä¸‹ä¸€æ–¹å—å­˜å‚¨
        // ä¿®æ”¹åçš„æ¸¸æˆæµç¨‹æ§åˆ¶
        function lockPiece() {
            currentPiece.shape.forEach((row, dy) => {
                row.forEach((cellVal, dx) => {
                    if (cellVal) {
                        const y = currentPiece.y + dy;
                        const x = currentPiece.x + dx;
                        // ç¡®ä¿åæ ‡æœ‰æ•ˆ
                        if (y >= 0 && y < ROWS && x >= 0 && x < COLS) {
                            board[y][x] = cellVal;
                        }
                    }
                });
            });
            // è®°å½•åº•éƒ¨æ¥è§¦ç‚¹
            currentPiece.shape.forEach((row, dy) => {
                row.forEach((cell, dx) => {
                    if (cell) {
                        const gridY = currentPiece.y + dy + 1;
                        if (gridY >= ROWS || board[gridY][currentPiece.x + dx]) {
                            currentPiece.addImpactPoint(
                                currentPiece.x + dx,
                                currentPiece.y + dy
                            );
                        }
                    }
                });
            });
            if (currentStyle === 'glass') {
                currentPiece.shape.forEach((row, dy) => {
                    row.forEach((cell, dx) => {
                        if (cell) {
                            // ç”Ÿæˆæ¥è§¦ç¢ç‰‡
                            const debris = new Particle(
                                (currentPiece.x + dx) * CELL_SIZE + CELL_SIZE / 2,
                                (currentPiece.y + dy) * CELL_SIZE + CELL_SIZE / 2,
                                currentPiece.color
                            );
                            debris.vy = -Math.random() * 3;
                            debris.vx = (Math.random() - 0.5) * 2;
                            particles.push(debris);
                        }
                    });
                });
            }
        }

        // è£‚çº¹ç”Ÿæˆé€»è¾‘
        function generateCracksFromImpact() {
            currentPiece.impactPoints.forEach(point => {
                for (let dy = -1; dy <= 1; dy++) {
                    for (dx = -1; dx <= 1; dx++) {
                        const y = point.y + dy;
                        const x = point.x + dx;
                        if (y >= 0 && y < ROWS && x >= 0 && x < COLS) {
                            cracks[y][x] = true;
                        }
                    }
                }
            });

            // æ·»åŠ ç»ç’ƒç ´ç¢éŸ³æ•ˆ
            // if (currentStyle === 'glass') {
            //     playTone(1500, 0.2, 'sawtooth');
            //     playTone(900, 0.3, 'square');
            // }
        }

        // æ–°å¢ä¸‹ä¸€ä¸ªæ–¹å—ç»˜åˆ¶
        function drawNext() {
            const ctx = document.getElementById('nextBlock').getContext('2d');
            ctx.clearRect(0, 0, 80, 80);
            if (!nextPiece) return; // æ·»åŠ ç©ºå€¼æ£€æŸ¥
            ctx.fillStyle = nextPiece.color;
            const offsetX = (4 - nextPiece.shape[0].length) * 10;
            nextPiece.shape.forEach((row, dy) => {
                row.forEach((cell, dx) => {
                    if (cell) ctx.fillRect(
                        dx * 20 + offsetX,
                        dy * 20 + 10,
                        18, 18
                    );
                });
            });
        }


        // æ¸¸æˆå¾ªç¯ä¸æ¸²æŸ“
        let currentPiece = null;
        let gameInterval = null;

        // æ·»åŠ ç²’å­æ•°é‡é™åˆ¶ï¼ˆé˜²æ­¢æ€§èƒ½ä¸‹é™ï¼‰
        const MAX_PARTICLES = 3000;

        function drawBoard() {
            updateColors();
            const ctx = document.getElementById('gameBoard').getContext('2d');
            ctx.clearRect(0, 0, ctx.canvas.width, ctx.canvas.height);
            ctx.save();

            // å±å¹•æŠ–åŠ¨æ•ˆæœ
            if (shakeIntensity > 0) {
                ctx.translate(
                    (Math.random() - 0.5) * shakeIntensity,
                    (Math.random() - 0.5) * shakeIntensity
                );
            }

            // ç»˜åˆ¶ç²’å­æ•ˆæœ
            // particles = particles.filter(p => {
            //     p.update();
            //     return p.life > 0;
            // }).slice(-MAX_PARTICLES);
            particles.forEach(p => p.draw(ctx));

            // ç»˜åˆ¶å›ºå®šæ–¹å—ï¼ˆåº”ç”¨å½“å‰æ ·å¼ï¼‰
            board.forEach((row, y) => row.forEach((cell, x) => {
                if (cell) {
                    const isBomb = cell === 8; // ç›´æ¥é€šè¿‡å•å…ƒæ ¼å€¼åˆ¤æ–­
                    const color = isBomb ? bombColor : COLORS[cell - 1];
                    applyBlockStyle(ctx, color, x * CELL_SIZE, y * CELL_SIZE, isBomb);
                }
            }));

            // ç»˜åˆ¶å½“å‰æ–¹å—æŠ•å½±
            if (currentPiece) {
                let dropDistance = 0;
                while (!currentPiece.collision(0, dropDistance + 1)) {
                    dropDistance++;
                }
                const shadowY = currentPiece.y + dropDistance;

                currentPiece.shape.forEach((row, dy) => {
                    row.forEach((cell, dx) => {
                        if (cell) {
                            const xPos = (currentPiece.x + dx) * CELL_SIZE;
                            const yPos = (shadowY + dy) * CELL_SIZE;
                            const isBomb = cell === 8;
                            let shadowColor = isBomb ? bombColor : currentPiece.color;

                            // æ ¹æ®ä¸»é¢˜è°ƒæ•´æŠ•å½±æ ·å¼
                            switch (currentStyle) {
                                case 'neon':
                                    shadowColor = hexToRGBA(shadowColor, 0.2);
                                    break;
                                case 'gradient':
                                    shadowColor = shadeColor(shadowColor, -30);
                                    break;
                                case 'glass':
                                    shadowColor = hexToRGBA(shadowColor, 0.15);
                                    break;
                                case 'retro':
                                    shadowColor = '#000000';
                                    break;
                                case 'metal':
                                    shadowColor = shadeColor(shadowColor, -40);
                                    break;
                                default:
                                    shadowColor = hexToRGBA(shadowColor, 0.3);
                            }

                            // ä¿å­˜å½“å‰çŠ¶æ€ååº”ç”¨æŠ•å½±æ ·å¼
                            ctx.save();
                            applyBlockStyle(ctx, shadowColor, xPos, yPos, isBomb, true);
                            ctx.restore();
                        }
                    });
                });
            }

            // ç»˜åˆ¶å½“å‰ä¸‹è½æ–¹å—ï¼ˆåº”ç”¨å½“å‰æ ·å¼ï¼‰
            if (currentPiece) {
                currentPiece.shape.forEach((row, dy) => {
                    row.forEach((cell, dx) => {
                        if (cell) {
                            const xPos = (currentPiece.x + dx) * CELL_SIZE;
                            const yPos = (currentPiece.y + dy) * CELL_SIZE;
                            // ç›´æ¥é€šè¿‡å•å…ƒæ ¼å€¼åˆ¤æ–­æ˜¯å¦ä¸ºç‚¸å¼¹
                            const isBomb = cell === 8;
                            const color = isBomb ? bombColor : currentPiece.color;
                            applyBlockStyle(ctx, color, xPos, yPos, isBomb, true);
                        }
                    });
                });
            }

            // ç»˜åˆ¶çˆ†ç‚¸åŠ¨ç”»
            // explosionAnimations = explosionAnimations.filter(anim => {
            //     anim.scale += 0.15;
            //     anim.alpha -= 0.03;
            //     ctx.save();
            //     ctx.globalAlpha = anim.alpha;
            //     ctx.fillStyle = anim.color;
            //     ctx.beginPath();
            //     ctx.arc(anim.x, anim.y, anim.scale * 3, 0, Math.PI * 2);
            //     ctx.fill();
            //     ctx.restore();
            //     return anim.alpha > 0;
            // });

            explosionAnimations.forEach(anim => {
                ctx.save();
                ctx.globalAlpha = anim.alpha;
                ctx.fillStyle = anim.color;
                ctx.beginPath();
                ctx.arc(anim.x, anim.y, anim.scale * 3, 0, Math.PI * 2);
                ctx.fill();
                ctx.restore();
            });

            // ç»˜åˆ¶åŠ¨æ€è£‚çº¹
            ctx.strokeStyle = 'rgba(255, 255, 255, 0.8)';
            ctx.lineWidth = 1.2;
            ctx.lineCap = 'round'; // æ·»åŠ åœ†è§’ç«¯ç‚¹

            if (currentStyle === 'glass') {
                // ç»˜åˆ¶é™æ€è£‚çº¹
                // cracks.forEach((row, y) => {
                //     row.forEach((hasCrack, x) => {
                //         if (hasCrack) {
                //             ctx.strokeStyle = 'rgba(255, 255, 255, 0.4)';
                //             ctx.lineWidth = 1.2;

                //             // ç»˜åˆ¶ä¸»è£‚çº¹
                //             ctx.beginPath();
                //             ctx.moveTo(x * CELL_SIZE + 5, y * CELL_SIZE + 5);
                //             ctx.lineTo(x * CELL_SIZE + CELL_SIZE - 5, y * CELL_SIZE + CELL_SIZE - 5);
                //             ctx.stroke();

                //             // ç»˜åˆ¶è¾…åŠ©è£‚çº¹
                //             ctx.beginPath();
                //             ctx.moveTo(x * CELL_SIZE + CELL_SIZE - 5, y * CELL_SIZE + 5);
                //             ctx.lineTo(x * CELL_SIZE + 5, y * CELL_SIZE + CELL_SIZE - 5);
                //             ctx.stroke();
                //         }
                //     });
                // });
            }

            // ç™½å…‰è¦†ç›–æ•ˆæœ
            if (whiteAlpha > 0) {
                ctx.fillStyle = `rgba(255, 255, 255, ${whiteAlpha})`;
                ctx.fillRect(0, 0, 300, 600);
            }

            ctx.restore();
        }

        // æ ·å¼åº”ç”¨å‡½æ•°
        function applyBlockStyle(ctx, color, x, y, isBomb, isShadow) {
            const size = CELL_SIZE - 1;

            // æŠ•å½±ç‰¹æ®Šå¤„ç†
            if (isShadow) {
                switch (currentStyle) {
                    case 'neon':
                        ctx.globalAlpha = 0.4;
                        ctx.shadowColor = color;
                        ctx.shadowBlur = 15;
                        break;
                    case 'glass':
                        ctx.globalAlpha = 0.3;
                        ctx.strokeStyle = 'rgba(255,255,255,0.2)';
                        break;
                    case 'retro':
                        ctx.globalAlpha = 0.6;
                        color = '#000000';
                        break;
                    default:
                        ctx.globalAlpha = 0.3;
                }
            }

            switch (currentStyle) {
                case 'neon':
                    // éœ“è™¹è¾¹æ¡†æ•ˆæœ
                    if (isShadow) {
                        ctx.shadowBlur = 10;
                        ctx.fillStyle = hexToRGBA(color, 0.2);
                    }
                    ctx.fillStyle = color;
                    ctx.fillRect(x, y, size, size);

                    ctx.strokeStyle = '#ffffff';
                    ctx.lineWidth = 2;
                    ctx.strokeRect(x + 1, y + 1, size - 2, size - 2);

                    // å‘å…‰æ•ˆæœ
                    ctx.shadowColor = color;
                    ctx.shadowBlur = 8;
                    ctx.strokeRect(x + 1, y + 1, size - 2, size - 2);
                    ctx.shadowBlur = 0;
                    break;

                case 'gradient': {
                    // ä¿®æ­£æ¸å˜æ–¹å‘å¹¶æ·»åŠ é¢œè‰²åœæ­¢ç‚¹
                    const gradient = ctx.createLinearGradient(x, y, x + size, y + size);
                    gradient.addColorStop(0, color);
                    gradient.addColorStop(1, shadeColor(color, -30));
                    ctx.fillStyle = gradient;
                    ctx.fillRect(x, y, size, size);
                    // æ·»åŠ ç«‹ä½“è¾¹æ¡†
                    ctx.strokeStyle = shadeColor(color, -20);
                    ctx.lineWidth = 2;
                    ctx.strokeRect(x, y, size, size);
                    break;
                }
                case 'pixel':
                    // ä¿®æ­£åƒç´ é£æ ¼çš„ç»˜åˆ¶é€»è¾‘
                    ctx.fillStyle = shadeColor(color, -30);  // æ·±è‰²è¾¹æ¡†
                    ctx.fillRect(x, y, size, size);          // å¤–æ¡†
                    ctx.fillStyle = color;                   // ä¸»é¢œè‰²
                    ctx.fillRect(x + 2, y + 2, size - 4, size - 4); // å†…éƒ¨æ–¹å—
                    // æ·»åŠ åƒç´ ç‚¹æ•ˆæœ
                    ctx.fillStyle = shadeColor(color, 20);   // é«˜å…‰
                    ctx.fillRect(x + size - 4, y + 2, 2, 2); // å³ä¸‹è§’é«˜å…‰
                    break;

                case 'candy': {
                    // ç³–æœé£æ ¼ï¼šæŸ”å’Œçš„åœ†è§’çŸ©å½¢
                    ctx.beginPath();
                    ctx.roundRect(x + 2, y + 2, size - 4, size - 4, 6);
                    ctx.fillStyle = color;
                    ctx.fill();

                    // æ·»åŠ ç³–æœå…‰æ³½æ•ˆæœ
                    const gradient = ctx.createLinearGradient(x, y, x + size, y + size);
                    gradient.addColorStop(0, 'rgba(255, 255, 255, 0.3)');
                    gradient.addColorStop(1, 'rgba(255, 255, 255, 0)');
                    ctx.fillStyle = gradient;
                    ctx.fill();

                    // æ·»åŠ ç³–æœå¤–æ¡†
                    ctx.strokeStyle = shadeColor(color, -20);
                    ctx.lineWidth = 2;
                    ctx.stroke();
                    break;
                }
                case 'retro':
                    // å¤å¤é£æ ¼ï¼šGame Boyæ ·å¼
                    ctx.fillStyle = color;
                    ctx.fillRect(x, y, size, size);

                    // æ·»åŠ åƒç´ åŒ–ç½‘æ ¼æ•ˆæœ
                    ctx.fillStyle = shadeColor(color, -30);
                    for (let i = 0; i < size; i += 2) {
                        for (let j = 0; j < size; j += 2) {
                            if ((i + j) % 4 === 0) {
                                ctx.fillRect(x + i, y + j, 2, 2);
                            }
                        }
                    }

                    // æ·»åŠ å¤å¤è¾¹æ¡†
                    ctx.strokeStyle = '#0F380F';
                    ctx.lineWidth = 1;
                    ctx.strokeRect(x, y, size, size);
                    break;

                case 'metal': {
                    // åŸºç¡€é‡‘å±è‰²
                    const baseColor = color;
                    // åˆ›å»ºæ¸å˜
                    const gradient = ctx.createLinearGradient(x, y, x + size, y + size);
                    gradient.addColorStop(0, shadeColor(baseColor, 20));
                    gradient.addColorStop(0.5, baseColor);
                    gradient.addColorStop(1, shadeColor(baseColor, -20));
                    ctx.fillStyle = gradient;
                    ctx.fillRect(x, y, size, size);

                    // æ·»åŠ é«˜å…‰è¾¹ç¼˜
                    ctx.strokeStyle = 'rgba(255, 255, 255, 0.3)';
                    ctx.lineWidth = 2;
                    ctx.strokeRect(x + 1, y + 1, size - 2, size - 2);

                    // æ·»åŠ å†…éƒ¨åå…‰
                    ctx.beginPath();
                    ctx.rect(x + 2, y + 2, size - 4, size - 4);
                    const highlight = ctx.createLinearGradient(x, y, x + size, y + size);
                    highlight.addColorStop(0, 'rgba(255, 255, 255, 0.1)');
                    highlight.addColorStop(1, 'rgba(255, 255, 255, 0)');
                    ctx.fillStyle = highlight;
                    ctx.fill();

                    // æ·»åŠ é“†é’‰æ•ˆæœ
                    ctx.fillStyle = 'rgba(0, 0, 0, 0.2)';
                    ctx.beginPath();
                    ctx.arc(x + size * 0.2, y + size * 0.2, 2, 0, Math.PI * 2);
                    ctx.arc(x + size * 0.8, y + size * 0.8, 2, 0, Math.PI * 2);
                    ctx.fill();
                    break;
                }

                // case 'glass': {
                //     // åˆ é™¤ç»ç’ƒè£‚çº¹æ•ˆæœ
                //     ctx.save();
                //     ctx.fillStyle = hexToRGBA(color, 0.6);
                //     ctx.fillRect(x, y, size, size);
                //     ctx.strokeStyle = 'rgba(255, 255, 255, 0.4)';
                //     ctx.lineWidth = 2;
                //     ctx.strokeRect(x + 1, y + 1, size - 2, size - 2);
                //     const gradient = ctx.createLinearGradient(x, y, x + size, y + size);
                //     gradient.addColorStop(0, 'rgba(255, 255, 255, 0.2)');
                //     gradient.addColorStop(1, 'rgba(255, 255, 255, 0)');
                //     ctx.fillStyle = gradient;
                //     ctx.fillRect(x, y, size, size);
                //     ctx.restore();
                //     break;
                // }

                case 'glass': {
                    if (isShadow) {
                        ctx.lineWidth = 1;
                        ctx.strokeStyle = 'rgba(255,255,255,0.3)';
                    }
                    // åŸºç¡€å¡«å……
                    ctx.fillStyle = color;
                    ctx.fillRect(x, y, size, size);

                    // æ·»åŠ MCé£æ ¼è¾¹æ¡†
                    ctx.strokeStyle = getComputedStyle(document.documentElement)
                        .getPropertyValue('--glass-border').trim();
                    ctx.lineWidth = 2;
                    ctx.strokeRect(x + 0.5, y + 0.5, size - 1, size - 1);

                    // å†…éƒ¨çº¹ç†æ•ˆæœ
                    ctx.save();
                    ctx.globalAlpha = 0.3;
                    for (let i = 0; i < 15; i++) { // æ·»åŠ éšæœºå™ªç‚¹
                        const px = x + Math.random() * (size - 2) + 1;
                        const py = y + Math.random() * (size - 2) + 1;
                        ctx.fillStyle = `rgba(255, 255, 255, ${Math.random() * 0.4})`;
                        ctx.fillRect(px, py, 1, 1);
                    }
                    ctx.restore();

                    // è¾¹ç¼˜åŠ æ·±æ•ˆæœ
                    ctx.fillStyle = 'rgba(0, 0, 0, 0.1)';
                    ctx.fillRect(x, y, size, 2);          // ä¸Šè¾¹ç¼˜
                    ctx.fillRect(x, y + size - 2, size, 2); // ä¸‹è¾¹ç¼˜
                    ctx.fillRect(x, y, 2, size);          // å·¦è¾¹ç¼˜
                    ctx.fillRect(x + size - 2, y, 2, size); // å³è¾¹ç¼˜

                    // æ·»åŠ ä¸­å¿ƒé«˜å…‰
                    const gradient = ctx.createRadialGradient(
                        x + size / 2, y + size / 2, size / 4,
                        x + size / 2, y + size / 2, size / 2
                    );
                    gradient.addColorStop(0, 'rgba(255, 255, 255, 0.2)');
                    gradient.addColorStop(1, 'rgba(255, 255, 255, 0)');
                    ctx.fillStyle = gradient;
                    ctx.fillRect(x, y, size, size);

                    // å¦‚æœæ˜¯ç‚¸å¼¹æ˜¾ç¤ºç‰¹æ®Šæ ‡è®°
                    if (isBomb) {
                        ctx.font = `${CELL_SIZE - 6}px Arial`;
                        ctx.fillStyle = 'rgba(0, 0, 0, 0.5)';
                        ctx.textAlign = 'center';
                        ctx.fillText('â€»', x + size / 2, y + size / 2 + 4);
                    }
                    break;
                }

                case 'neon':
                    // éœ“è™¹å‘å…‰æ•ˆæœ
                    ctx.fillStyle = color;
                    ctx.shadowColor = color;
                    ctx.shadowBlur = 15;
                    ctx.beginPath();
                    ctx.roundRect(x + 2, y + 2, CELL_SIZE - 4, CELL_SIZE - 4, 4);
                    ctx.fill();

                    // æ·»åŠ è„‰å†²åŠ¨ç”»
                    const pulse = Math.sin(Date.now() / 100) * 2 + 2;
                    ctx.shadowBlur = 15 + pulse;
                    ctx.fill();
                    break;

                case 'forest':
                    // è‡ªç„¶æœ¨çº¹æ•ˆæœ
                    ctx.fillStyle = color;
                    ctx.fillRect(x, y, CELL_SIZE - 1, CELL_SIZE - 1);

                    // æ·»åŠ æœ¨çº¹çº¹ç†
                    ctx.fillStyle = shadeColor(color, -20);
                    for (let i = 0; i < 6; i++) {
                        const w = Math.random() * 8 + 2;
                        ctx.fillRect(x + Math.random() * (CELL_SIZE - w), y, w, CELL_SIZE);
                    }
                    break;

                case 'ocean':
                    // æ°´æ³¢çº¹æ•ˆæœ
                    const gradient = ctx.createLinearGradient(x, y, x + CELL_SIZE, y + CELL_SIZE);
                    gradient.addColorStop(0, shadeColor(color, 20));
                    gradient.addColorStop(1, shadeColor(color, -20));
                    ctx.fillStyle = gradient;
                    ctx.beginPath();
                    ctx.arc(x + CELL_SIZE / 2, y + CELL_SIZE / 2, CELL_SIZE / 2 - 2, 0, Math.PI * 2);
                    ctx.fill();

                    // æ·»åŠ æ³¡æ²«æ•ˆæœ
                    ctx.fillStyle = 'rgba(255,255,255,0.2)';
                    for (let i = 0; i < 3; i++) {
                        ctx.beginPath();
                        ctx.arc(x + Math.random() * CELL_SIZE, y + Math.random() * CELL_SIZE, 2, 0, Math.PI * 2);
                        ctx.fill();
                    }
                    break;

                default:
                    // é»˜è®¤æ ·å¼
                    ctx.fillStyle = color;
                    ctx.fillRect(x, y, size, size);
                    // æ·»åŠ é«˜å…‰
                    ctx.fillStyle = 'rgba(255, 255, 255, 0.2)';
                    ctx.fillRect(x + 2, y + 2, size / 2 - 2, size / 2 - 2);
            }

            if (isBomb) {
                ctx.font = `${CELL_SIZE - 6}px Arial`;
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';
                ctx.fillText('ğŸ’£', x + size / 2, y + size / 2 + 2);

                ctx.shadowColor = color;
                ctx.shadowBlur = 10;
                ctx.fillStyle = 'rgba(255, 255, 255, 0.9)';
                ctx.fillText('ğŸ’£', x + size / 2, y + size / 2 + 2);
                ctx.shadowBlur = 0;
            }

            if (currentStyle === 'glass') {
                // ç»˜åˆ¶ç»ç’ƒè£‚ç¼
                const gridX = Math.floor(x / CELL_SIZE);
                const gridY = Math.floor(y / CELL_SIZE);
                if (cracks[gridY] && cracks[gridY][gridX]) {
                    ctx.strokeStyle = 'rgba(255, 255, 255, 0.3)';
                    ctx.lineWidth = 1;
                    ctx.beginPath();
                    // éšæœºç”Ÿæˆ3-5æ¡è£‚ç¼çº¿
                    for (let i = 0; i < 3 + Math.floor(Math.random() * 3); i++) {
                        const startX = x + Math.random() * CELL_SIZE;
                        const startY = y + Math.random() * CELL_SIZE;
                        ctx.moveTo(startX, startY);
                        ctx.lineTo(startX + Math.random() * 10 - 5, startY + Math.random() * 10 - 5);
                    }
                    ctx.stroke();
                }
            }
        }

        // é¢œè‰²è½¬æ¢è¾…åŠ©å‡½æ•°
        function hexToRGBA(hex, alpha) {
            const r = parseInt(hex.slice(1, 3), 16),
                g = parseInt(hex.slice(3, 5), 16),
                b = parseInt(hex.slice(5, 7), 16);
            return `rgba(${r}, ${g}, ${b}, ${alpha})`;
        }

        // æ¸¸æˆæš‚åœ
        function pauseGame() {
            if (gameInterval) {
                clearInterval(gameInterval);
                gameInterval = null;
                isPaused = true;
                document.querySelector('.buttons button:nth-child(2)').textContent = 'ç»§ç»­(C)';
            } else if (isPaused) {
                gameInterval = setInterval(gameLoop, 1000);
                isPaused = false;
                document.querySelector('.buttons button:nth-child(2)').textContent = 'æš‚åœ(P)';
            }
        }


        // ç”¨æˆ·è¾“å…¥å¤„ç†
        document.addEventListener('keydown', e => {
            if (e.key.toLowerCase() === 'p') { // å¢åŠ Pé”®æš‚åœåŠŸèƒ½
                pauseGame();
                return;
            }
            if (e.key.toLowerCase() === 'c' && isPaused) { // cé”®ä»…åœ¨æš‚åœæ—¶ç”Ÿæ•ˆ
                pauseGame();
                return;
            }
            if (!currentPiece) return;

            switch (e.key) {
                case 'ArrowLeft':
                    if (!currentPiece.collision(-1, 0)) currentPiece.x--;
                    break;
                case 'ArrowRight':
                    if (!currentPiece.collision(1, 0)) currentPiece.x++;
                    break;
                case 'ArrowDown':
                    if (!currentPiece.collision(0, 1)) currentPiece.y++;
                    break;
                case 'ArrowUp':
                    currentPiece.rotate();
                    break;
                case ' ': // ç©ºæ ¼é”®å¿«é€Ÿä¸‹è½
                    while (!currentPiece.collision(0, 1)) currentPiece.y++;
                    break;
            }
            drawBoard();
            switch (e.key) {
                case 'ArrowLeft':
                    soundEffects.move();
                    break;
                case 'ArrowRight':
                    soundEffects.move();
                    break;
                case 'ArrowDown':
                    soundEffects.drop();
                    break;
                case 'ArrowUp':
                    soundEffects.rotate();
                    break;
                case ' ':
                    soundEffects.drop();
                    break;
            }
        });


        // é«˜çº§åŠŸèƒ½æ‰©å±•
        // â€‹è¡Œæ¶ˆé™¤é€»è¾‘
        function clearLines() {
            let linesCleared = 0;
            let bombs = []; // å­˜å‚¨æ£€æµ‹åˆ°çš„ç‚¸å¼¹ä½ç½®
            let y = ROWS - 1;
            // å€’åºéå†æ‰€æœ‰è¡Œ
            // for (let y = ROWS - 1; y >= 0; y--) {
            //     // æ£€æŸ¥å½“å‰è¡Œæ˜¯å¦è¢«å¡«æ»¡ï¼ˆåŒ…å«æ™®é€šæ–¹å—æˆ–ç‚¸å¼¹ï¼‰
            //     if (board[y].every(cell => cell !== 0)) {
            //         // éå†è¯¥è¡Œçš„æ¯ä¸ªå•å…ƒæ ¼
            //         board[y].forEach((cell, x) => {
            //             // æ£€æµ‹ç‚¸å¼¹å¹¶å­˜å‚¨ä½ç½®
            //             if (cell === 8) { // 8 è¡¨ç¤ºç‚¸å¼¹æ–¹å—
            //                 bombs.push({ x, y });
            //             }

            //             // æ™®é€šæ–¹å—æ¶ˆé™¤ç‰¹æ•ˆï¼ˆç”Ÿæˆç²’å­æ•ˆæœï¼‰
            //             if (cell !== 0 && cell !== 8) {
            //                 const color = COLORS[cell - 1];
            //                 // ç”Ÿæˆç²’å­æ•ˆæœ
            //                 for (let i = 0; i < 6; i++) {
            //                     particles.push(new Particle(x, y, color));
            //                 }
            //             }
            //         });

            //         // æ¶ˆé™¤å½“å‰è¡Œå¹¶æ·»åŠ æ–°è¡Œåˆ°é¡¶éƒ¨
            //         board.splice(y, 1);
            //         board.unshift(Array(COLS).fill(0));
            //         linesCleared++;
            //         y++; // å› ä¸ºåˆ é™¤äº†å½“å‰è¡Œï¼Œéœ€è¦é‡æ–°æ£€æŸ¥æ–°ç§»åŠ¨ä¸‹æ¥çš„è¡Œ
            //     }
            // }
            while (y >= 0) {
                if (board[y].every(cell => cell !== 0)) {
                    // è®°å½•ç‚¸å¼¹ä½ç½®
                    board[y].forEach((cell, x) => {
                        if (cell === 8) bombs.push({ x, y });
                        if (cell !== 0 && cell !== 8) {
                            for (let i = 0; i < 6; i++) {
                                particles.push(new Particle(x, y, COLORS[cell - 1]));
                            }
                        }
                    });

                    // åˆ é™¤è¡Œå¹¶æ·»åŠ æ–°è¡Œåˆ°é¡¶éƒ¨
                    board.splice(y, 1);
                    board.unshift(Array(COLS).fill(0));
                    linesCleared++;
                    // ä¿æŒyä¸å˜ä»¥æ£€æŸ¥æ–°ç§»åŠ¨ä¸‹æ¥çš„è¡Œ
                } else {
                    y--;
                }
            }

            // éŸ³é¢‘
            if (linesCleared > 0) {
                soundEffects.clearLine();
            }

            // å¤„ç†æ‰€æœ‰æ£€æµ‹åˆ°çš„ç‚¸å¼¹
            bombs.forEach(bomb => {
                const { x, y } = bomb;
                // è§¦å‘ç‚¸å¼¹çˆ†ç‚¸æ•ˆæœ
                explodeBomb(x, y);

                // ç”Ÿæˆç‚¸å¼¹çˆ†ç‚¸ç²’å­ï¼ˆçº¢è‰²ï¼‰
                for (let i = 0; i < 15; i++) {
                    particles.push(new Particle(x, y, bombColor, true)); // ä½¿ç”¨å˜é‡æ›¿ä»£ç¡¬ç¼–ç 
                }
            });

            // æ›´æ–°å¾—åˆ†ï¼ˆæ™®é€šæ¶ˆé™¤ï¼‰
            if (linesCleared > 0) {
                const scoreMap = { 1: 40, 2: 100, 3: 300, 4: 1200 };
                score += (scoreMap[linesCleared] || 0);
                document.getElementById('score').textContent = score;
            }

            // å¤„ç†è¿é”çˆ†ç‚¸ï¼ˆå¦‚æœå…¶ä»–ç‚¸å¼¹è¢«å½“å‰çˆ†ç‚¸è§¦å‘ï¼‰
            bombs.forEach(bomb => {
                // æ£€æŸ¥å‘¨å›´5x5èŒƒå›´å†…æ˜¯å¦æœ‰å…¶ä»–ç‚¸å¼¹
                for (let dy = -2; dy <= 2; dy++) {
                    for (let dx = -2; dx <= 2; dx++) {
                        const newX = bomb.x + dx;
                        const newY = bomb.y + dy;
                        if (newX >= 0 && newX < COLS && newY >= 0 && newY < ROWS) {
                            if (board[newY][newX] === 8) {
                                // è§¦å‘è¿é”çˆ†ç‚¸
                                explodeBomb(newX, newY);
                            }
                        }
                    }
                }
            });
            if (currentStyle === 'glass') {
                // ç”Ÿæˆéšæœºè£‚ç¼
                // for (let y = 0; y < ROWS; y++) {
                //     for (let x = 0; x < COLS; x++) {
                //         if (board[y][x] !== 0 && Math.random() < 0.2) {
                //             // åœ¨å‘¨å›´3x3åŒºåŸŸç”Ÿæˆè£‚ç¼
                //             for (let dy = -1; dy <= 1; dy++) {
                //                 for (let dx = -1; dx <= 1; dx++) {
                //                     if (y + dy >= 0 && y + dy < ROWS && x + dx >= 0 && x + dx < COLS) {
                //                         cracks[y + dy][x + dx] = cracks[y + dy][x + dx] || Math.random() < 0.4;
                //                     }
                //                 }
                //             }
                //         }
                //     }
                // }
                // éå†æ‰€æœ‰è¢«æ¶ˆé™¤çš„æ–¹å—
                board.forEach((row, y) => {
                    row.forEach((cell, x) => {
                        if (cell !== 0) {
                            // ç”Ÿæˆç»ç’ƒç¢ç‰‡
                            for (let i = 0; i < 3; i++) {
                                const debris = new Particle(
                                    x * CELL_SIZE + CELL_SIZE / 2,
                                    y * CELL_SIZE + CELL_SIZE / 2,
                                    COLORS[cell - 1]
                                );
                                // è®¾ç½®ç»ç’ƒç¢ç‰‡ç‰©ç†å‚æ•°
                                debris.vx = (Math.random() - 0.5) * 4;
                                debris.vy = (Math.random() - 2) * 3;
                                debris.gravity = 0.4;
                                debris.bounce = 0.6;
                                particles.push(debris);
                            }
                        }
                    });
                });
            }

        }

        // ç²’å­æ•ˆæœ
        class Particle {
            constructor(x, y, color, isExplosion = false) {
                this.collisionRadius = this.size * 0.7; // ç¢°æ’åŒºåŸŸä¸ºå®é™…å°ºå¯¸çš„70%
                // é¢œè‰²è®¾ç½®
                this.color = isExplosion ? bombColor : color;
                // åæ ‡è½¬æ¢ï¼ˆæ£‹ç›˜åæ ‡è½¬ç”»å¸ƒåæ ‡ï¼‰
                this.x = x * CELL_SIZE + CELL_SIZE / 2;
                this.y = y * CELL_SIZE + CELL_SIZE / 2;
                this.isExplosion = isExplosion;

                // ç²’å­è¿åŠ¨å‚æ•°è°ƒæ•´
                if (isExplosion) {
                    this.vx = (Math.random() - 0.5) * 8;   // æ°´å¹³é€Ÿåº¦èŒƒå›´ï¼š-4 ~ 4
                    this.vy = (Math.random() - 1.5) * 6;   // åˆå§‹å‘ä¸Šé€Ÿåº¦
                    this.gravity = 0.5;                    // é‡åŠ›ç¨å‡
                    this.life = 1.2;
                    this.size = 5;                         // å¢å¤§åˆå§‹å¤§å°
                } else {
                    this.vx = (Math.random() - 0.5) * 6;    // æ›´è‡ªç„¶çš„æ°´å¹³æ‰©æ•£
                    this.vy = (Math.random() - 2) * 4;      // åˆå§‹å‘ä¸Šé€Ÿåº¦
                    this.gravity = 0.4;                    // å‡å°é‡åŠ›
                    this.life = 1;
                    this.size = 4;                         // å¢å¤§æ™®é€šç²’å­
                }
                // æ·»åŠ ç»ç’ƒç¢ç‰‡ç‰¹æœ‰å±æ€§
                this.isGlass = currentStyle === 'glass';
                this.rotation = Math.random() * Math.PI * 2;
                this.rotationSpeed = (Math.random() - 0.5) * 0.2;
                this.shape = this.generateGlassShape();

                // è°ƒæ•´ç»ç’ƒç¢ç‰‡ç‰©ç†å±æ€§
                // if (this.isGlass) {
                //     this.gravity = 0.4;
                //     this.bounce = 0.6;
                //     this.life = 2.0; // æ›´é•¿çš„ç”Ÿå‘½å‘¨æœŸ
                //     this.decay = 0.015;
                // }
                if (this.isGlass) {
                    this.decay = 0.003; // ç”Ÿå‘½å‘¨æœŸå»¶é•¿è‡³çº¦3ç§’
                    this.gravity = 0.3;  // é€‚å½“è°ƒæ•´é‡åŠ›
                    this.bounce = 0.7;   // å¢åŠ å¼¹æ€§ç³»æ•°
                }
                this.decay = 0.02;                         // é€‚å½“å»¶é•¿ç”Ÿå‘½å‘¨æœŸ
                this.impactPoints = []; // è®°å½•ç¢°æ’æ—¶çš„æ¥è§¦ç‚¹

                // ç»ç’ƒç¢ç‰‡ç‰¹æœ‰å±æ€§
                this.isGlassDebris = currentStyle === 'glass' && isExplosion;
                if (this.isGlassDebris) {
                    this.life = 10 + Math.random() * 5; // ç”Ÿå‘½å‘¨æœŸ7-15ç§’
                    this.decay = 0.003;
                    this.mass = 1 + Math.random();
                    this.bounce = 0.6;
                    this.friction = 0.98;
                    this.isStatic = false;
                    this.collisionGrid = { x: -1, y: -1 };

                    // ç”Ÿæˆæ›´å¤æ‚çš„ç¢ç‰‡å½¢çŠ¶
                    this.shape = this.generateComplexShape();
                }
                if (this.isGlassDebris) {
                    this.decay = 0.015;  // åŠ å¿«æ¶ˆå¤±é€Ÿåº¦ï¼ˆçº¦3ç§’ç”Ÿå‘½å‘¨æœŸï¼‰
                    this.gravity = 0.4;
                    this.bounce = 0.6;
                    this.friction = 0.98;
                    this.mass = 0.8 + Math.random() * 0.4; // éšæœºè´¨é‡
                    this.size = 6 + Math.random() * 4;      // éšæœºå¤§å°
                }
            }

            // ç”Ÿæˆç»ç’ƒç¢ç‰‡å½¢çŠ¶ è®°å½•
            addImpactPoint(x, y) {
                this.impactPoints.push({ x, y });
            }

            generateGlassShape() {
                // ç”Ÿæˆéšæœºå¤šè¾¹å½¢å½¢çŠ¶
                const sides = Math.floor(Math.random() * 3) + 3; // 3-5è¾¹å½¢
                const points = [];
                const radius = this.size;

                for (let i = 0; i < sides; i++) {
                    const angle = (i / sides) * Math.PI * 2;
                    points.push({
                        x: Math.cos(angle) * radius,
                        y: Math.sin(angle) * radius
                    });
                }
                return points;
            }

            // ç”Ÿæˆå¤æ‚å¤šè¾¹å½¢å½¢çŠ¶
            generateComplexShape() {
                const sides = 3 + Math.floor(Math.random() * 3); // 3-5è¾¹
                const vertices = [];
                const radius = this.size;

                for (let i = 0; i < sides; i++) {
                    const angle = (i / sides) * Math.PI * 2 + Math.random() * 0.5;
                    vertices.push({
                        x: Math.cos(angle) * radius * (0.8 + Math.random() * 0.4),
                        y: Math.sin(angle) * radius * (0.8 + Math.random() * 0.4)
                    });
                }
                return vertices;
            }

            // æ›´æ–°ç‰©ç†æ¨¡æ‹Ÿ
            updatePhysics() {
                if (this.isStatic) return;

                // åº”ç”¨ç©ºæ°”é˜»åŠ›
                this.vx *= this.friction;
                this.vy *= this.friction;

                // åº”ç”¨é‡åŠ›
                this.vy += this.gravity * this.mass;

                // ä¿å­˜æ—§ä½ç½®ç”¨äºç¢°æ’æ£€æµ‹
                const oldX = this.x;
                const oldY = this.y;

                // æ›´æ–°ä½ç½®
                this.x += this.vx;
                this.y += this.vy;

                // è¾¹ç•Œç¢°æ’å¤„ç†ï¼ˆæ–°å¢åº•éƒ¨è¾¹ç•Œæ£€æµ‹ï¼‰
                this.handleBoundaryCollision(oldX, oldY);

                // æ›´æ–°ç©ºé—´åˆ†åŒºç½‘æ ¼
                this.updateCollisionGrid();

                // ç¢ç‰‡é—´ç¢°æ’æ£€æµ‹ï¼ˆä¼˜åŒ–åçš„ç‰ˆæœ¬ï¼‰
                this.handleDebrisCollision();

                // é™æ€æ£€æµ‹ï¼ˆå½“é€Ÿåº¦è¶³å¤Ÿå°æ—¶åœæ­¢ï¼‰
                if (Math.abs(this.vx) < 0.1 && Math.abs(this.vy) < 0.1) {
                    this.isStatic = true;
                }
            }

            // æ›´æ–°ç¢°æ’ç½‘æ ¼
            updateCollisionGrid() {
                const newGridX = Math.floor(this.x / GRID_SIZE);
                const newGridY = Math.floor(this.y / GRID_SIZE);

                if (newGridX !== this.collisionGrid.x || newGridY !== this.collisionGrid.y) {
                    // ä»æ—§ç½‘æ ¼ç§»é™¤
                    if (this.collisionGrid.x !== -1) {
                        const index = glassDebris[this.collisionGrid.y][this.collisionGrid.x]
                            .indexOf(this);
                        if (index > -1) glassDebris[this.collisionGrid.y][this.collisionGrid.x].splice(index, 1);
                    }

                    // æ·»åŠ åˆ°æ–°ç½‘æ ¼
                    if (!glassDebris[newGridY]) glassDebris[newGridY] = [];
                    if (!glassDebris[newGridY][newGridX]) glassDebris[newGridY][newGridX] = [];
                    glassDebris[newGridY][newGridX].push(this);

                    this.collisionGrid.x = newGridX;
                    this.collisionGrid.y = newGridY;
                }

                const canvasWidth = COLS * CELL_SIZE;
                const canvasHeight = ROWS * CELL_SIZE;
                const bounceFactor = 0.6;

                // å·¦å³è¾¹ç•Œ
                if (this.x < this.size) {
                    this.x = this.size;
                    this.vx *= -bounceFactor;
                } else if (this.x > canvasWidth - this.size) {
                    this.x = canvasWidth - this.size;
                    this.vx *= -bounceFactor;
                }

                // åº•éƒ¨è¾¹ç•Œï¼ˆå¢åŠ èƒ½é‡è¡°å‡ï¼‰
                if (this.y > canvasHeight - this.size) {
                    this.y = canvasHeight - this.size;
                    this.vy *= -bounceFactor;
                    this.vx *= 0.8; // æ°´å¹³æ‘©æ“¦
                    if (Math.abs(this.vy) < 1) this.vy = 0;
                }
            }

            // ç¢ç‰‡é—´ç¢°æ’å¤„ç†
            handleDebrisCollision() {
                const neighbors = [];
                const gridX = this.collisionGrid.x;
                const gridY = this.collisionGrid.y;

                // æ£€æµ‹3x3ç›¸é‚»ç½‘æ ¼
                for (let y = gridY - 1; y <= gridY + 1; y++) {
                    for (let x = gridX - 1; x <= gridX + 1; x++) {
                        if (glassDebris[y] && glassDebris[y][x]) {
                            neighbors.push(...glassDebris[y][x]);
                        }
                    }
                }

                neighbors.forEach(other => {
                    if (other === this || other.isStatic) return;

                    const dx = other.x - this.x;
                    const dy = other.y - this.y;
                    const distance = Math.sqrt(dx * dx + dy * dy);
                    const minDist = this.size + other.size;

                    if (distance < minDist && distance > 0) {
                        // ç¢°æ’å“åº”è®¡ç®—
                        const angle = Math.atan2(dy, dx);
                        const overlap = (minDist - distance) / 2;

                        // ä½ç½®ä¿®æ­£
                        this.x -= overlap * Math.cos(angle);
                        this.y -= overlap * Math.sin(angle);
                        other.x += overlap * Math.cos(angle);
                        other.y += overlap * Math.sin(angle);

                        // åŠ¨é‡äº¤æ¢
                        const v1 = { x: this.vx, y: this.vy };
                        const v2 = { x: other.vx, y: other.vy };

                        const normal = { x: dx / distance, y: dy / distance };
                        const tangent = { x: -normal.y, y: normal.x };

                        // æ³•å‘å’Œåˆ‡å‘é€Ÿåº¦
                        const v1n = normal.x * v1.x + normal.y * v1.y;
                        const v1t = tangent.x * v1.x + tangent.y * v1.y;
                        const v2n = normal.x * v2.x + normal.y * v2.y;
                        const v2t = tangent.x * v2.x + tangent.y * v2.y;

                        // å¼¹æ€§ç¢°æ’è®¡ç®—
                        const m1 = this.mass, m2 = other.mass;
                        const newV1n = (v1n * (m1 - m2) + 2 * m2 * v2n) / (m1 + m2);
                        const newV2n = (v2n * (m2 - m1) + 2 * m1 * v1n) / (m1 + m2);

                        // æ›´æ–°é€Ÿåº¦
                        this.vx = normal.x * newV1n + tangent.x * v1t;
                        this.vy = normal.y * newV1n + tangent.y * v1t;
                        other.vx = normal.x * newV2n + tangent.x * v2t;
                        other.vy = normal.y * newV2n + tangent.y * v2t;
                    }
                });
            }

            // è¾¹ç•Œç¢°æ’å¤„ç†
            handleBoundaryCollision(oldX, oldY) {
                const buffer = 2; // è¾¹ç•Œç¼“å†²

                // å·¦å³è¾¹ç•Œ
                if (this.x < buffer) {
                    this.x = buffer;
                    this.vx *= -this.bounce;
                } else if (this.x > COLS * CELL_SIZE - buffer) {
                    this.x = COLS * CELL_SIZE - buffer;
                    this.vx *= -this.bounce;
                }

                // åº•éƒ¨è¾¹ç•Œ
                if (this.y > ROWS * CELL_SIZE - buffer) {
                    this.y = ROWS * CELL_SIZE - buffer;
                    this.vy *= -this.bounce;
                    if (Math.abs(this.vy) < 1) this.vy = 0;
                }
            }

            update() {
                if (this.isGlassDebris) {
                    this.updatePhysics();
                    this.life -= this.decay;
                    this.alpha = Math.min(1, this.life * 0.2); // æ¸éšæ•ˆæœ
                } else {
                    // æ›´æ–°ä½ç½®å’Œé€Ÿåº¦
                    this.x += this.vx;
                    this.y += this.vy;
                    this.vy += this.gravity;

                    // æ›´æ–°ç”Ÿå‘½å‘¨æœŸ
                    this.life -= this.decay;

                    // çˆ†ç‚¸ç²’å­ç¼©å°æ•ˆæœ
                    if (this.isExplosion) {
                        this.size *= 0.95;
                    }

                    // æ·»åŠ ç»ç’ƒç¢ç‰‡ç¢°æ’æ£€æµ‹
                    if (this.isGlass) {
                        // è½¬æ¢ä¸ºç½‘æ ¼åæ ‡
                        const gridX = Math.floor(this.x / CELL_SIZE);
                        const gridY = Math.floor((this.y + this.size) / CELL_SIZE);
                        // æ£€æµ‹æ˜¯å¦ç¢°åˆ°ç°æœ‰æ–¹å—
                        if (gridY >= 0 && gridY < ROWS && gridX >= 0 && gridX < COLS) {
                            if (board[gridY][gridX] !== 0) {
                                this.vy = 0;
                                this.y = gridY * CELL_SIZE - this.size;
                                this.vx *= 0.6; // ç¢°æ’åæ°´å¹³é€Ÿåº¦è¡°å‡
                            }
                        }
                        // åº•éƒ¨ç¢°æ’æ£€æµ‹ï¼ˆæ¸¸æˆæ¿é«˜åº¦ä¸ºROWS*CELL_SIZEï¼‰
                        if (this.y > ROWS * CELL_SIZE - this.size) {
                            this.y = ROWS * CELL_SIZE - this.size;
                            this.vy *= -this.bounce;
                            this.vx *= 0.8;
                        }

                        // æ°´å¹³è¾¹ç•Œåå¼¹
                        if (this.x < this.size) {
                            this.x = this.size;
                            this.vx *= -this.bounce;
                        }
                        if (this.x > COLS * CELL_SIZE - this.size) {
                            this.x = COLS * CELL_SIZE - this.size;
                            this.vx *= -this.bounce;
                        }
                    }

                    this.rotation += this.rotationSpeed;
                }

            }

            draw(ctx) {
                if (this.isGlassDebris) {
                    ctx.save();
                    ctx.globalAlpha = this.alpha;
                    ctx.translate(this.x, this.y);
                    ctx.rotate(this.rotation);

                    // ç»˜åˆ¶å¤æ‚å½¢çŠ¶
                    ctx.beginPath();
                    this.shape.forEach((vert, index) => {
                        if (index === 0) ctx.moveTo(vert.x, vert.y);
                        else ctx.lineTo(vert.x, vert.y);
                    });
                    ctx.closePath();

                    // æ·»åŠ å…‰ç…§æ•ˆæœ
                    const gradient = ctx.createLinearGradient(
                        -this.size, -this.size,
                        this.size, this.size
                    );
                    gradient.addColorStop(0, 'rgba(255,255,255,0.3)');
                    gradient.addColorStop(1, 'rgba(255,255,255,0)');

                    ctx.fillStyle = this.color;
                    ctx.fill();
                    ctx.fillStyle = gradient;
                    ctx.fill();

                    ctx.restore();
                } else {
                    // è®¾ç½®ç²’å­é¢œè‰²
                    ctx.fillStyle = this.color;
                    // åœ¨å¤å¤é£æ ¼ä¸­ä½¿ç”¨æ–¹å½¢ç²’å­
                    if (currentStyle === 'retro') {
                        ctx.fillRect(
                            this.x - this.size / 2,
                            this.y - this.size / 2,
                            this.size,
                            this.size
                        );
                    } else {
                        // å…¶ä»–é£æ ¼ä½¿ç”¨åœ†å½¢ç²’å­
                        ctx.beginPath();
                        ctx.arc(this.x, this.y, this.size, 0, Math.PI * 2);
                        ctx.fill();
                    }
                }

            }
        }

        // çˆ†ç‚¸éŸ³æ•ˆ
        class GlassCrack {
            // constructor(startX, startY, angle) {
            //     this.points = [{ x: startX, y: startY }];
            //     this.angle = angle;
            //     this.progress = 0;
            //     this.speed = Math.random() * 0.04 + 0.02; // åŠ å¿«ç”Ÿé•¿é€Ÿåº¦
            //     this.branches = [];
            //     this.maxBranches = 2; // æ§åˆ¶åˆ†æ”¯æ•°é‡
            // }

            // update() {
            //     if (this.progress < 1) {
            //         this.progress += this.speed;
            //         // æ·»åŠ éšæœºæŠ–åŠ¨
            //         const jitter = Math.PI / 8 * (Math.random() - 0.5);
            //         const currentAngle = this.angle + jitter;

            //         // æ·»åŠ æ–°ç‚¹
            //         const newPoint = {
            //             x: this.points[this.points.length - 1].x +
            //                 Math.cos(currentAngle) * 4,
            //             y: this.points[this.points.length - 1].y +
            //                 Math.sin(currentAngle) * 4
            //         };
            //         this.points.push(newPoint);

            //         // éšæœºç”Ÿæˆåˆ†æ”¯
            //         if (Math.random() < 0.3 &&
            //             this.branches.length < this.maxBranches) {
            //             const branchAngle = currentAngle +
            //                 (Math.random() - 0.5) * Math.PI / 1.5;
            //             this.branches.push(new GlassCrack(
            //                 newPoint.x,
            //                 newPoint.y,
            //                 branchAngle
            //             ));
            //         }
            //     }

            //     // æ›´æ–°åˆ†æ”¯
            //     this.branches.forEach(branch => branch.update());
            // }
        }

        // çˆ†ç‚¸æ•ˆæœ
        function explodeBomb(x, y) {
            // éŸ³é¢‘
            soundEffects.bomb();
            // ç»ç’ƒç ´ç¢éŸ³æ•ˆ
            if (currentStyle === 'glass') {
                playTone(1200, 0.5, 'sawtooth');
                playTone(800, 0.5, 'square');
            }
            // æ¸…é™¤å·²æœ‰éœ‡åŠ¨å®šæ—¶å™¨
            if (window.shakeTimer) clearInterval(window.shakeTimer);

            // è®¾ç½®éœ‡åŠ¨å‚æ•°ï¼ˆæœ€å¤§å¼ºåº¦30ï¼‰
            shakeIntensity = Math.min(30, shakeIntensity + 8);

            // éœ‡åŠ¨è¡°å‡å®šæ—¶å™¨
            window.shakeTimer = setInterval(() => {
                shakeIntensity *= 0.85;
                if (shakeIntensity < 0.5) {
                    clearInterval(window.shakeTimer);
                    shakeIntensity = 0;
                }
            }, 16);

            const explosionRadius = 2; // å½±å“5x5åŒºåŸŸ
            let bombScore = 0;

            // æ¸…é™¤çˆ†ç‚¸èŒƒå›´å†…çš„æ–¹å—
            for (let dy = -explosionRadius; dy <= explosionRadius; dy++) {
                for (let dx = -explosionRadius; dx <= explosionRadius; dx++) {
                    const newX = x + dx;
                    const newY = y + dy;

                    if (newX >= 0 && newX < COLS && newY >= 0 && newY < ROWS) {
                        if (board[newY][newX] !== 0) {
                            // ç”Ÿæˆçˆ†ç‚¸ç²’å­
                            for (let i = 0; i < 3; i++) {
                                particles.push(new Particle(newX, newY, bombColor, true));
                            }

                            // è®°å½•è¢«ç‚¸æ¯çš„æ–¹å—
                            bombScore += 10;
                            board[newY][newX] = 0;
                        }
                    }
                }
            }

            // æ›´æ–°å¾—åˆ†
            score += bombScore;
            document.getElementById('score').textContent = score;

            // æ·»åŠ çˆ†ç‚¸åŠ¨ç”»
            explosionAnimations.push({
                x: x * CELL_SIZE + CELL_SIZE / 2,
                y: y * CELL_SIZE + CELL_SIZE / 2,
                color: bombColor,
                scale: 1,
                alpha: 1
            });

            // è§¦å‘å±å¹•éœ‡åŠ¨
            shakeIntensity = Math.min(15, shakeIntensity + 8);

            // åœ¨çˆ†ç‚¸æ—¶ç”Ÿæˆç»ç’ƒç¢ç‰‡
            const debrisCount = 20 + Math.floor(Math.random() * 10);
            for (let i = 0; i < debrisCount; i++) {
                const angle = Math.random() * Math.PI * 2;
                const speed = 4 + Math.random() * 6;
                const debris = new Particle(
                    x * CELL_SIZE + CELL_SIZE / 2,
                    y * CELL_SIZE + CELL_SIZE / 2,
                    bombColor,
                    true
                );

                // è®¾ç½®æ›´è‡ªç„¶çš„åˆå§‹é€Ÿåº¦
                debris.vx = Math.cos(angle) * speed;
                debris.vy = Math.sin(angle) * speed - 4;
                debris.rotationSpeed = (Math.random() - 0.5) * 0.15;

                // æ·»åŠ éšæœºæ—‹è½¬
                debris.rotation = Math.random() * Math.PI * 2;

                particles.push(debris);
            }

            const isGlassStyle = currentStyle === 'glass';
            const explosionCount = isGlassStyle ? 25 : 15;

            for (let i = 0; i < explosionCount; i++) {
                particles.push(new Particle(x, y, bombColor, true));
            }

            if (currentStyle === 'glass') {
                const debrisCount = 15 + Math.floor(Math.random() * 10);
                for (let i = 0; i < debrisCount; i++) {
                    const debris = new Particle(
                        x * CELL_SIZE + CELL_SIZE / 2,
                        y * CELL_SIZE + CELL_SIZE / 2,
                        bombColor,
                        true
                    );

                    // è®¾ç½®éšæœºåˆå§‹é€Ÿåº¦
                    const angle = Math.random() * Math.PI * 2;
                    const speed = 3 + Math.random() * 5;
                    debris.vx = Math.cos(angle) * speed;
                    debris.vy = Math.sin(angle) * speed - 3;

                    particles.push(debris);
                }
            }
        }

        // å±å¹•ç‰¹æ•ˆå‡½æ•°
        function startScreenEffects() {
            // æ¸…é™¤å·²æœ‰éœ‡åŠ¨å®šæ—¶å™¨
            if (window.shakeTimer) clearInterval(window.shakeTimer);

            // åˆ›å»ºå…¨å±ç™½å…‰åŠ¨ç”»
            const overlay = document.createElement('div');
            overlay.className = 'game-over-overlay';
            document.body.appendChild(overlay);

            // å¯åŠ¨å±å¹•æŠ–åŠ¨ï¼ˆæŒç»­0.3ç§’ï¼‰
            shakeIntensity = 15;

            // éœ‡åŠ¨è¡°å‡å®šæ—¶å™¨
            window.shakeTimer = setInterval(() => {
                shakeIntensity *= 0.85;
            }, 16);

            // 0.3ç§’åå¼ºåˆ¶åœæ­¢éœ‡åŠ¨
            setTimeout(() => {
                clearInterval(window.shakeTimer);
                shakeIntensity = 0;
            }, 300);

            // å¯åŠ¨æ¸å…¥ç™½å…‰
            let whiteTimer = setInterval(() => {
                whiteAlpha = Math.min(whiteAlpha + 0.02, 0.6);
                if (whiteAlpha >= 0.6) clearInterval(whiteTimer);
            }, 16);

            // 1.5ç§’åé‡ç½®å…¶ä»–çŠ¶æ€
            setTimeout(() => {
                isGameOver = true;
                explosionAnimations = [];
                document.body.removeChild(overlay);
            }, 1500);
        }

        // æ–°å¢ç‹¬ç«‹æ¸²æŸ“å¾ªç¯
        function gameRender(timestamp) {
            // æ¸…é™¤è¶…è¿‡ç”Ÿå‘½å‘¨æœŸçš„ç¢ç‰‡
            particles = particles.filter(p => {
                if (p.isGlassDebris) return p.life > 0;
                return true;
            });

            // å§‹ç»ˆè¿è¡Œæ¸²æŸ“å¾ªç¯
            const deltaTime = timestamp - lastTime;
            if (deltaTime > 1000 / frameRate) {
                // æ›´æ–°ç²’å­æ•ˆæœ
                particles = particles.filter(p => {
                    p.update();
                    return p.life > 0;
                }).slice(-MAX_PARTICLES);

                // æ›´æ–°çˆ†ç‚¸åŠ¨ç”»
                explosionAnimations = explosionAnimations.filter(anim => {
                    anim.scale += 0.15;
                    anim.alpha -= 0.03;
                    return anim.alpha > 0;
                });

                drawBoard();
                lastTime = timestamp;
            }
            // æ›´æ–°è£‚çº¹åŠ¨ç”»
            // activeCracks = activeCracks.filter(crack => {
            //     crack.update();
            //     return crack.progress < 1 || crack.branches.length > 0;
            // });

            // æ›´æ–°è£‚çº¹åŠ¨ç”»ï¼ˆè¡¥å……è¿™éƒ¨åˆ†ï¼‰
            // activeCracks.forEach(crack => crack.update());

            // // å¤„ç†åˆ†æ”¯è£‚çº¹ï¼ˆæ–°å¢ä»£ç ï¼‰
            // activeCracks = activeCracks.reduce((acc, crack) => {
            //     acc.push(crack);
            //     crack.branches.forEach(branch => acc.push(branch));
            //     return acc;
            // }, []);

            // è¿‡æ»¤å·²å®Œæˆè£‚çº¹ï¼ˆè¡¥å……è¿‡æ»¤æ¡ä»¶ï¼‰
            // activeCracks = activeCracks.filter(crack =>
            //     crack.progress < 1 || crack.branches.some(b => b.progress < 1)
            // );

            // å½“æ–¹å—é”å®šæ—¶ç”Ÿæˆæ–°è£‚çº¹
            // if (needGenerateCracks) {
            //     generateCracksFromImpact();
            //     needGenerateCracks = false;
            // }
            requestAnimationFrame(gameRender);
        }

        // â€‹æ¸¸æˆæµç¨‹æ§åˆ¶
        function gameLoop() {
            if (currentPiece.collision(0, 1)) {
                lockPiece();
                needGenerateCracks = true;
                clearLines();

                // ç¡®ä¿æ­£ç¡®ä¼ é€’ä¸‹ä¸€ä¸ªæ–¹å—
                currentPiece = nextPiece;
                currentPiece.x = Math.floor(COLS / 2) - Math.floor(currentPiece.shape[0].length / 2);
                currentPiece.y = 0;

                // ç”Ÿæˆæ–°æ–¹å—å‰æ£€æŸ¥æœ‰æ•ˆæ€§
                nextPiece = new Tetromino();
                drawNext();

                // ä¼˜åŒ–ç¢°æ’æ£€æµ‹
                if (currentPiece.collision(0, 0)) {
                    setTimeout(() => { // å»¶è¿Ÿæ£€æµ‹é¿å…è¯¯åˆ¤
                        if (currentPiece.collision(0, 0)) gameOver();
                    }, 50);
                }
            } else {
                currentPiece.y++;
            }
            drawBoard();
        }

        function startGame() {
            initCanvasSize();
            if (isGameOver) {
                currentPiece = new Tetromino();
                nextPiece = new Tetromino();
                drawNext();
                // ä½¿ç”¨å½“å‰å°ºå¯¸åˆå§‹åŒ–æ¸¸æˆæ¿
                board = Array(ROWS).fill().map(() => Array(COLS).fill(0));

                score = 0;
                document.getElementById('score').textContent = score;
                // éŸ³é¢‘
                initAudio();
                if (audioContext.state === 'suspended') {
                    audioContext.resume();
                }
                bgMusic.play().catch(() => { });


                if (gameInterval) return;
                if (window.shakeTimer) clearInterval(window.shakeTimer);
                isGameOver = false; // é‡ç½®æ¸¸æˆç»“æŸçŠ¶æ€
                board = Array(ROWS).fill().map(() => Array(COLS).fill(0));
                score = 0;
                whiteAlpha = 0;      // é‡ç½®ç™½å…‰é€æ˜åº¦
                shakeIntensity = 0;  // é‡ç½®æŠ–åŠ¨å¼ºåº¦
                particles = [];     // æ¸…ç©ºç²’å­æ•ˆæœ
                // nextPiece = new Tetromino();
                // currentPiece = new Tetromino();
                // drawNext();
                gameInterval = setInterval(gameLoop, 1000);

                // ä¿æŒæ¸¸æˆé€»è¾‘æ›´æ–°é¢‘ç‡ï¼ˆ30fpsï¼‰
                // gameInterval = setInterval(gameLoop, 1000 / 30);

                // å¯åŠ¨ç‹¬ç«‹æ¸²æŸ“å¾ªç¯ï¼ˆ60fpsï¼‰
                requestAnimationFrame(gameRender);
                cracks = Array(ROWS).fill().map(() => Array(COLS).fill(false));
            }
            else {
                isGameOver = false; // é‡ç½®æ¸¸æˆç»“æŸçŠ¶æ€
            }
            const validatePosition = (piece) => {
                piece.x = Math.floor(COLS / 2) - Math.floor(piece.shape[0].length / 2);
                if (piece.collision(0, 0)) {
                    piece.y = -1; // å…è®¸åŠæ ¼è¿›å…¥
                }
            };

            validatePosition(currentPiece);
            validatePosition(nextPiece);
            cracks = Array(ROWS).fill().map(() => Array(COLS).fill(false)); // ä½¿ç”¨falseåˆå§‹åŒ–
        }

        // æ–°å¢æ¸¸æˆç»“æŸå¤„ç†
        function gameOver() {
            // éŸ³é¢‘
            soundEffects.gameOver();
            bgMusic.pause();

            clearInterval(gameInterval);
            gameInterval = null;
            isGameOver = true; // æ ‡è®°æ¸¸æˆç»“æŸçŠ¶æ€
            // alert(`æ¸¸æˆç»“æŸï¼å¾—åˆ†ï¼š${score}`);
            // æ”¶é›†æ‰€æœ‰æ–¹å—ç”¨äºçˆ†ç‚¸åŠ¨ç”»
            board.forEach((row, y) => {
                row.forEach((cell, x) => {
                    if (cell) {
                        explosionAnimations.push({
                            x: x * CELL_SIZE + CELL_SIZE / 2,
                            y: y * CELL_SIZE + CELL_SIZE / 2,
                            color: bombColor, // ä½¿ç”¨ç‚¸å¼¹é¢œè‰²å˜é‡
                            scale: 1,
                            alpha: 1
                        });

                        // ç”Ÿæˆçˆ†ç‚¸ç²’å­
                        for (let i = 0; i < 8; i++) {
                            particles.push(new Particle(x, y, COLORS[cell - 1], true));
                        }
                    }
                });
            });

            // æ¸…ç©ºæ¸¸æˆæ¿
            board = Array(ROWS).fill().map(() => Array(COLS).fill(0));

            // å¯åŠ¨å±å¹•ç‰¹æ•ˆ
            startScreenEffects();
        }


        // ä¸»é¢˜åˆ‡æ¢ğŸ‘‡

        // ä¸»é¢˜åˆ‡æ¢åŠŸèƒ½
        const themeToggle = document.getElementById('themeToggle');

        // åˆå§‹åŒ–ä¸»é¢˜
        const savedTheme = localStorage.getItem('theme') || 'light';
        document.documentElement.setAttribute('data-theme', savedTheme);
        themeToggle.checked = savedTheme === 'dark';

        // åˆ‡æ¢äº‹ä»¶
        themeToggle.addEventListener('change', (e) => {
            const theme = e.target.checked ? 'dark' : 'light';
            document.documentElement.setAttribute('data-theme', theme);
            localStorage.setItem('theme', theme);
            document.querySelector('.theme-label').textContent = theme === 'dark' ? 'å¤œé—´æ¨¡å¼' : 'ç™½å¤©æ¨¡å¼';
            updateColors();
            drawBoard();
            drawNext();
            if (nextPiece) {
                nextPiece.color = COLORS[nextPiece.shapeIndex]; // æ›´æ–°ä¸‹ä¸€æ–¹å—é¢œè‰²
                drawNext();
            }
        });

        // åˆå§‹åŒ–æ—¶æ›´æ–°é¢œè‰²
        updateColors();

        document.addEventListener('touchstart', e => {
            touchStartX = e.touches[0].clientX;
            touchStartY = e.touches[0].clientY;
        });

        document.addEventListener('touchmove', e => {
            e.preventDefault(); // é˜»æ­¢é»˜è®¤æ»šåŠ¨è¡Œä¸º
        }, { passive: false });

        document.addEventListener('touchend', e => {
            if (!currentPiece) return;

            const deltaX = e.changedTouches[0].clientX - touchStartX;
            const deltaY = e.changedTouches[0].clientY - touchStartY;

            if (Math.abs(deltaX) > Math.abs(deltaY)) {
                if (deltaX > touchThreshold) {
                    currentPiece.x++;
                    soundEffects.move();
                } else if (deltaX < -touchThreshold) {
                    currentPiece.x--;
                    soundEffects.move();
                }
            } else {
                if (deltaY > touchThreshold) {
                    while (!currentPiece.collision(0, 1)) currentPiece.y++;
                    soundEffects.drop();
                } else if (deltaY < -touchThreshold) {
                    currentPiece.rotate();
                    soundEffects.rotate();
                }
            }
            drawBoard();
        });

        // è™šæ‹ŸæŒ‰é’®äº‹ä»¶ç»‘å®š
        document.querySelectorAll('.mobile-btn').forEach(btn => {
            btn.addEventListener('touchstart', (e) => {
                e.preventDefault();
                const action = {
                    'left-btn': () => currentPiece.x--,
                    'right-btn': () => currentPiece.x++,
                    'rotate-btn': () => currentPiece.rotate(),
                    'down-btn': () => currentPiece.y++
                }[btn.classList[1]];

                if (action && !currentPiece.collision(0, 0, action)) {
                    action();
                    drawBoard();
                }
            }, { passive: true });
        });

        // è°ƒæ•´æ¸¸æˆåˆå§‹åŒ–å°ºå¯¸
        function initCanvasSize() {
            const isMobile = /Android|webOS|iPhone|iPad/i.test(navigator.userAgent);
            if (isMobile) {
                const boardWidth = Math.min(window.innerWidth * 0.9, 300);
                const cellSize = boardWidth / COLS;

                const gameBoard = document.getElementById('gameBoard');
                gameBoard.width = boardWidth;
                gameBoard.height = cellSize * ROWS;
            }
        }

        // åœ¨window resizeæ—¶è°ƒæ•´ç”»å¸ƒ
        window.addEventListener('resize', () => {
            initCanvasSize();
            drawBoard();
        });

        // æ·»åŠ æ¨ªå±æ£€æµ‹
        function checkOrientation() {
            if (window.innerHeight > window.innerWidth) {
                alert("å»ºè®®æ¨ªå±ä½“éªŒæ›´ä½³ï¼");
            }
        }
        window.addEventListener('resize', checkOrientation);
    </script>
</body>

</html>